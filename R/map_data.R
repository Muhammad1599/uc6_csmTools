###---- TEMP -----
map_tmp <- data.frame(
  column_header = unique(
    unlist(lapply(BNR_full, function(df) colnames(df)), use.names = FALSE)
  )
)

#joins <- read.delim("clipboard")

map_tmp_2 <- map_tmp %>%
  left_join(joins, by = "column_header")

map_tmp_2 <- map_tmp_2 %>%
  rename(raw_var = column_header,  ##!!
         std_var = std_header,
         raw_unit = column_unit) %>%
  dplyr::select(raw_var, raw_unit, std_var, std_unit, code_mappings)

# Drop NAs
map_tmp_2 <- mutate_all(map_tmp_2, ~ifelse(is.na(.x), "", .x))
  
         
#' Convert a mapping code list stored in a data frame as a string into a lookup table
#' 
#' The string format is analogous to the code_mapping field in standard ARDN SC2 json files around which the standard
#' mapping files for the package will be build. See: https://agmip.github.io/ARDN/Annotation_SC2.html
#' 
#' @param str a code mapping list [format: list('source1: target1', 'source2: target2')] stored as a string
#' 
#' @return a lookup dataframe with 2 columns: source (original data) and target (standard data)
#' 
#' @importFrom rlang eval_tidy parse_expr
#' 
#' @export
#'

make_code_lookup <- function(str){
  
  ls <- eval_tidy(parse_expr(str))
  ls <- strsplit(as.character(ls), ": ")
  ls <- lapply(ls, function(x) c(source = x[1], target = x[2]))
  df <- as.data.frame(do.call(rbind, ls))
  
  return(df)
}


#' Map categorical data to standard codes
#' 
#' Currently handles lookup tables as maps rather than json SC2 files, which will be implemented in the future.
#' 
#' @param df a data frame of the data to be mapped
#' @param map a lookup table of the categories to be madde to standard codes, as generated by 'made_code_lookup'
#' 
#' @return a data frame with codes mapped to the format specified in the supplied map
#' 
#' @importFrom dplyr recode_factor
#' 
#' @export
#'

map_codes <- function(df, map){
  
  map <- map[map$std_var %in% colnames(df),]
  
  for (i in 1:nrow(map)){
    
    if (is.na(map$std_unit[i]) | map$std_unit[i] == "") {
      next
    }
    
    if (map$std_unit[i] == "code") {
      
      header <- map$std_var[i]
      
      mappings <- map$code_mappings[i]
      lookup <- make_code_lookup(mappings)
      var <- df[[header]]
      
      df[[header]] <- recode_factor(var, !!!setNames(as.list(lookup$target), lookup$source))
    }
  }
  return(df)
}


#' Convert numeric variables based on units provided as strings
#' 
#' ####str unit formats
#' 
#' @param x a numeric to be converted
#' @param u1 the input unit, in which x is expressed
#' @param u2 the target unit, in which the output is expressed
#' 
#' @return a converted numeric
#' 
#' @importFrom units set_units
#' 
#' @export
#'

convert_unit <- function(x, u1, u2){
  set_units(x, u1, mode = "standard") %>% set_units(u2, mode = "standard") %>% as.numeric()
}


#' Map a data table into a standard format
#' 
#' Currently only handles exact matches (header names, units, and codes). Future versions will handle more complex
#' data mapping (e.g., conditional, concatenation, etc.)
#' 
#' @param df a data frame of the data to be mapped
#' @param map a lookup table detailing input and target headers, units, and codes
#' 
#' @return a data frame with headers, units, and codes mapped to the format specified in the map
#' 
#' @export
#'

map_data <- function(df, map){
  
  # Map headers
  for (i in seq_along(colnames(df))) {
    for (j in 1:nrow(map)){
      
      if (colnames(df)[i] == map$raw_var[j]){
        if (is.na(map$raw_var[j]) | map$std_var[j] == "") {
          next
        }
        colnames(df)[i] <- map$std_var[j]
      }
    }
  }
  
  # Map codes
  df <- map_codes(df, map)
  
  # Convert units
  
  ## if != & is.numeric
  ##
  #convert_unit(0.6, unit1, unit2)
  
  return(df)
}


### example
tmp <- map_data(BNR_full$EXPERIMENTS, map_tmp_2)

