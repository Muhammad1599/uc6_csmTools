#' Convert a mapping code list stored in a data frame as a string into a lookup table
#' 
#' The string format is analogous to the code_mapping field in standard ARDN SC2 json files around which the standard
#' mapping files for the package will be build. See: https://agmip.github.io/ARDN/Annotation_SC2.html
#' 
#' @param str a code mapping list [format: list('source1: target1', 'source2: target2')] stored as a string
#' 
#' @return a lookup dataframe with 2 columns: source (original data) and target (standard data)
#' 
#' @importFrom rlang eval_tidy parse_expr
#' 
#' @export
#'

make_code_lookup <- function(str){
  
  ls <- eval_tidy(parse_expr(str))
  ls <- strsplit(as.character(ls), ": ")
  ls <- lapply(ls, function(x) c(source = x[1], target = x[2]))
  df <- as.data.frame(do.call(rbind, ls))
  
  return(df)
}


#' Map categorical data to standard codes
#' 
#' Currently handles lookup tables as maps rather than json SC2 files, which will be implemented in the future.
#' 
#' @param df a data frame of the data to be mapped
#' @param map a lookup table of the categories to be madde to standard codes, as generated by 'made_code_lookup'
#' 
#' @return a data frame with codes mapped to the format specified in the supplied map
#' 
#' @importFrom dplyr recode_factor
#' 
#' @export
#'

map_codes <- function(df, map){
  
  map <- map[map$std_header %in% colnames(df),]
  
  for (i in 1:nrow(map)){
  
    if (is.na(map$std_unit[i]) | map$std_unit[i] == "") {
      next
    }
    
    if (map$std_unit[i] == "code") {
      
      header <- map$std_header[i]
      
      mappings <- map$code_mappings[i]
      lookup <- make_code_lookup(mappings)
      var <- df[[header]]
      
      print(header)
      df[[header]] <- recode_factor(var, !!!setNames(as.list(lookup$target), lookup$source))
    }
  }
  return(df)
}


#' Convert numeric variables based on units provided as strings
#' 
#' ####str unit formats
#' 
#' @param x a numeric to be converted
#' @param u1 the input unit, in which x is expressed
#' @param u2 the target unit, in which the output is expressed
#' 
#' @return a converted numeric
#' 
#' @importFrom units set_units
#' 
#' @export
#'

convert_unit <- function(x, u1, u2){
  set_units(x, u1, mode = "standard") %>% set_units(u2, mode = "standard") %>% as.numeric()
}


#' Map a data table into a standard format
#' 
#' Currently only handles exact matches (header names, units, and codes). Future versions will handle more complex
#' data mapping (e.g., conditional, concatenation, etc.)
#' 
#' @param df a data frame of the data to be mapped
#' @param map a lookup table detailing input and target headers, units, and codes
#' 
#' @return a data frame with headers, units, and codes mapped to the format specified in the map
#' 
#' @export
#'

map_data <- function(df, tbl_name, map){
  
  map <- map[map$table_name == tbl_name,]
  
  # Map headers
  for (i in seq_along(colnames(df))) {
    for (j in 1:nrow(map)){
      
      if (colnames(df)[i] == map$column_header[j]){
        if (is.na(map$column_header[j]) | map$std_header[j] == "") {
          next
        }
        colnames(df)[i] <- map$std_header[j]
      }
    }
  }
  
  # Map codes
  df <- map_codes(df, map)
  
  # Convert units
  for (i in seq_along(colnames(df))) {
    for (j in 1:nrow(map)){
      
      if (colnames(df)[i] == map$std_header[j]){
        if (is.na(map$std_header[j]) |
            map$std_unit[j] %in% c("","date","code","text","yyyy")) {
          next
        }
        df[[i]] <- convert_unit(df[[i]], map$column_unit[j], map$std_unit[j])
      }
    }
  }
  
  return(df)
}


