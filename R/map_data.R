#' Convert a mapping code list stored in a data frame as a string into a lookup table
#' 
#' The string format is analogous to the code_mapping field in standard ARDN SC2 json files around which the standard
#' mapping files for the package will be build. See: https://agmip.github.io/ARDN/Annotation_SC2.html
#' 
#' @param vec a code mapping list [format: list('source1: target1', 'source2: target2')] stored as a string
#' 
#' @return a lookup dataframe with 2 columns: source (original data) and target (standard data)
#' 
#' @importFrom rlang eval_tidy parse_expr
#' 
#' @export
#'

make_code_lookup <- function(vec){
  
  if (vec == "1") {
    lkp <- data.frame(source = NA_character_, tagret = NA_character_)
  } else {
    
    ls <- eval_tidy(parse_expr(vec))
    ls <- strsplit(as.character(ls), ": ")
    ls <- lapply(ls, function(x) list(source = x[1], target = x[2]))
    
    ls_lkp <- lapply(ls, function(lst) {
      if (grepl("c\\(", lst$source)) {
        df <- data.frame(source = strsplit(gsub("[c()]", "", lst$source), ", ")[[1]],
                         target = lst$target)
        return(df)
      } else {
        df <- as.data.frame(do.call(cbind, lst))
        return(df)
      }
      return(ls)
    })
    
    lkp <- as.data.frame(do.call(rbind, ls_lkp))
    
    lkp$target <- ifelse(lkp$target == 1, lkp$source, lkp$target)
  }

  return(lkp)
}


#' Map categorical data to standard codes
#' 
#' Currently handles lookup tables as maps rather than json SC2 files, which will be implemented in the future.
#' 
#' @param df a data frame of the data to be mapped
#' @param map a lookup table of the categories to be madde to standard codes, as generated by 'made_code_lookup'
#' 
#' @return a data frame with codes mapped to the format specified in the supplied map
#' 
#' @importFrom dplyr recode_factor
#' 
#' @export
#'

map_codes <- function(df, map){
  
  map <- map[map$std_header %in% colnames(df),]
  
  for (i in 1:nrow(map)){

    if (map$std_unit[i] == "code") {

      header <- map$std_header[i]
      
      mappings <- map$code_mappings[i]
      lookup <- make_code_lookup(mappings)
      var <- df[[header]]
      
      if (all(is.na(lookup))) {
        next
      } else {
        df[[header]] <- recode_factor(var, !!!setNames(as.list(lookup$target), lookup$source), .default = NA_character_)
      }
    }
  }
  return(df)
}


#' Convert numeric variables based on units provided as strings
#' 
#' ####str unit formats
#' 
#' @param x a numeric to be converted
#' @param u1 the input unit, in which x is expressed
#' @param u2 the target unit, in which the output is expressed
#' 
#' @return a converted numeric
#' 
#' @importFrom units set_units
#' 
#' @export
#'

convert_unit <- function(x, u1, u2){
  set_units(x, u1, mode = "standard") %>% set_units(u2, mode = "standard") %>% as.numeric()
}


#' Map a data table into a standard format
#' 
#' Currently only handles exact matches (header names, units, and codes). Future versions will handle more complex
#' data mapping (e.g., conditional, concatenation, etc.)
#' 
#' @param df a data frame of the data to be mapped
#' @param map a lookup table detailing input and target headers, units, and codes
#' 
#' @return a data frame with headers, units, and codes mapped to the format specified in the map
#' 
#' @export
#'

map_data <- function(df, tbl_name, map, keep_unmapped = TRUE){
  
  map <- map[map$table_name == tbl_name,]
  
  # Map headers
  for (i in seq_along(colnames(df))) {
    for (j in 1:nrow(map)){
      
      if (colnames(df)[i] == map$column_header[j]){
        if (is.na(map$column_header[j]) | map$std_header[j] == "") {
          next
        }
        colnames(df)[i] <- map$std_header[j]
      }
    }
  }
  
  # Map codes
  df <- map_codes(df, map)
  
  # Convert units
  for (i in seq_along(colnames(df))) {
    for (j in 1:nrow(map)){
      
      if (colnames(df)[i] == map$std_header[j]){
        if (is.na(map$std_header[j]) |
            map$std_unit[j] %in% c("","date","code","text","yyyy")) {
          next
        }
        df[[i]] <- convert_unit(df[[i]], map$column_unit[j], map$std_unit[j])
      }
    }
  }
  
  # Drop columns not in standard if required
  if (keep_unmapped == FALSE) {
    
    map_std <- map %>%
      filter(!is.na(std_header) & std_header != "") %>%
      pull(std_header)
    
    df <- distinct(df[,colnames(df) %in% map_std])
  }
  
  return(df)
}


